






















































































































Preprepared YOLOV8n LIVE package---
https://filetransfer.io/data-package/gg3YRpk9#link

--> to run my prebuilt package.
--> download and extract.
--> setup the camera as given in the below steps.
--> open the root folder of project in cmd
--> pip install --upgrade pip (if not work then use pip3 install --upgrade pip3)
--> pip install -r requirements/requirements.txt
--> open detect.py in Thony and run.



Step-by-Step Guide for Object Detection on Raspberry Pi Using YOLO and Ultralyics (from scratch)
_________________________________________________________________________________


1. Set Up the Camera-------------------------------------------------------------

1a) Connect the Camera - Plug your Raspberry Pi camera module into the camera port on the board. Ensure it's firmly attached.

1b) Enable the Camera Interface - Open the terminal and run:
>>  sudo raspi-config

1c) In the dialog box:--> Navigate to Interface Options. --> Select Camera and enable it (choose Yes). --> Press Esc to return and exit the configuration tool.

1d) Reboot the Raspberry Pi --> Open the terminal and run:
>>  sudo reboot

_________________________________________________________________________________


2. Test the Camera---------------------------------------------------------------

2a) To capture an image:	>>  libcamera-still -o test1.jpg --vflip --hflip

2b) To record a video:		>>  libcamera-vid --width 1920 --height 1080 -o full_hd.h264


_________________________________________________________________________________


3.  Install Required Libraries---------------------------------------------------

3a) Ensure your Raspberry Pi is up to date:	
	>>  sudo apt update
	>>  sudo apt upgrade

3b) Install picamera2
	>>  pip3 install picamera2

3c) Install OpenCV for Python:
	>>  sudo apt install python3-opencv


_________________________________________________________________________________


4. Set Up YOLO with Ultralyics---------------------------------------------------

4a) Install ultralytics Library
	>>  pip3 install ultralytics

4b) Download YOLO Weights - No additional steps are required here.


_________________________________________________________________________________


5. Python Code for Object Detection Using YOLOv8---------------------------------
filename --> yolo_object_detection.py
save the code anywhere no matter lets say save on desktop
---------------------------------------------------------------------------------


from picamera2 import Picamera2
from ultralytics import YOLO
import cv2
import numpy as np

# Initialize camera
picam2 = Picamera2()
camera_config = picam2.create_preview_configuration(main={"format": "RGB888", "size": (640, 480)})
picam2.configure(camera_config)
picam2.start()

# Load YOLOv8 model
model = YOLO("yolov8n.pt")  # Use a pre-trained YOLOv8 model

print("Press 'q' to exit the program.")

while True:
    # Capture frame from camera
    frame = picam2.capture_array()

    # Perform object detection
    results = model.predict(frame, show=False, save=False)

    # Draw bounding boxes and labels on the frame
    annotated_frame = np.array(results[0].plot())

    # Display the frame
    cv2.imshow("YOLOv8 Object Detection", annotated_frame)

    # Exit on pressing 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release resources
picam2.stop()
cv2.destroyAllWindows()


_________________________________________________________________________________

6. Running the Script------------------------------------------------------------


6a) Save the Python script (e.g., yolo_object_detection.py).

6b) Open file location in cmd 
	>>  python3 yolo_object_detection.py

(if above command not works try >> python yolo_object_detection.py)

6c) Press q to quit when done.



_________________________________________________________________________________


TROUBLESHOOTING -Common Issues and Fixes

Library Errors - If you get errors about missing libraries, re-install them with:
>>  pip3 install --force-reinstall <library_name>


Permission Issues - Ensure the script has the proper permissions:
>>  chmod +x yolo_object_detection.py


Camera Errors - 
	If the camera doesn’t work:
	Check its connection.
	Run libcamera-still or libcamera-vid to verify its functionality.



Optional Tools for Debugging--->
Check Camera - If the camera doesn’t work, use the following to debug:
	Test image capture:
	>>  libcamera-still -o test.jpg

	Test video recording:
	>>  libcamera-vid -o test_video.h264


	If the script crashes, you can log errors for debugging:
	>>  python3 yolo_object_detection.py > error_log.txt 2>&1


_________________________________________________________________________________





____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________

// TRAFFIC LIGHT 4 WAY RPI - trafficlight.py


import RPi.GPIO as GPIO
import time

GPIO.setwarnings(False)

north_green = 2
north_yellow = 3
north_red = 4
south_green = 17
south_yellow = 27
south_red = 22
east_green = 10
east_yellow = 9
east_red = 11
west_green = 5
west_yellow = 6
west_red = 13

GPIO.setmode(GPIO.BCM)

traffic_lights = [
    north_green, north_yellow, north_red,
    south_green, south_yellow, south_red,
    east_green, east_yellow, east_red,
    west_green, west_yellow, west_red
]

for pin in traffic_lights:
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.LOW)

def switch_to_green_north_south():
    GPIO.output(north_green, GPIO.HIGH)
    GPIO.output(north_yellow, GPIO.LOW)
    GPIO.output(north_red, GPIO.LOW)
    GPIO.output(south_green, GPIO.HIGH)
    GPIO.output(south_yellow, GPIO.LOW)
    GPIO.output(south_red, GPIO.LOW)
    GPIO.output(east_green, GPIO.LOW)
    GPIO.output(east_yellow, GPIO.LOW)
    GPIO.output(east_red, GPIO.HIGH)
    GPIO.output(west_green, GPIO.LOW)
    GPIO.output(west_yellow, GPIO.LOW)
    GPIO.output(west_red, GPIO.HIGH)

def switch_to_yellow_north_south():
    GPIO.output(north_green, GPIO.LOW)
    GPIO.output(north_yellow, GPIO.HIGH)
    GPIO.output(north_red, GPIO.LOW)
    GPIO.output(south_green, GPIO.LOW)
    GPIO.output(south_yellow, GPIO.HIGH)
    GPIO.output(south_red, GPIO.LOW)

def switch_to_green_east_west():
    GPIO.output(north_green, GPIO.LOW)
    GPIO.output(north_yellow, GPIO.LOW)
    GPIO.output(north_red, GPIO.HIGH)
    GPIO.output(south_green, GPIO.LOW)
    GPIO.output(south_yellow, GPIO.LOW)
    GPIO.output(south_red, GPIO.HIGH)
    GPIO.output(east_green, GPIO.HIGH)
    GPIO.output(east_yellow, GPIO.LOW)
    GPIO.output(east_red, GPIO.LOW)
    GPIO.output(west_green, GPIO.HIGH)
    GPIO.output(west_yellow, GPIO.LOW)
    GPIO.output(west_red, GPIO.LOW)

def switch_to_yellow_east_west():
    GPIO.output(east_green, GPIO.LOW)
    GPIO.output(east_yellow, GPIO.HIGH)
    GPIO.output(east_red, GPIO.LOW)
    GPIO.output(west_green, GPIO.LOW)
    GPIO.output(west_yellow, GPIO.HIGH)
    GPIO.output(west_red, GPIO.LOW)

try:
    while True:
        switch_to_green_north_south()
        time.sleep(5)
        switch_to_yellow_north_south()
        time.sleep(2)
        switch_to_green_east_west()
        time.sleep(5)
        switch_to_yellow_east_west()
        time.sleep(2)

except KeyboardInterrupt:
    GPIO.cleanup()


_____________________________________________________________________

LONGER LEG  +ve (anode)
SHORTER LEG -ve (cathode)

North-South LEDs:

Green LED: Connect the anode to GPIO2.
Yellow LED: Connect the anode to GPIO3.
Red LED: Connect the anode to GPIO4.
South LEDs:

Green LED: Connect the anode to GPIO17.
Yellow LED: Connect the anode to GPIO27.
Red LED: Connect the anode to GPIO22.
East-West LEDs:

East Green LED: Connect the anode to GPIO10.
East Yellow LED: Connect the anode to GPIO9.
East Red LED: Connect the anode to GPIO11.
West Green LED: Connect the anode to GPIO5.
West Yellow LED: Connect the anode to GPIO6.
West Red LED: Connect the anode to GPIO13.

_____________________________________________________________________


3.3V     pin1                  pin2   5V
GPIO2    pin3                  pin4   5V
GPIO3    pin5                  pin6   GND
GPIO4    pin7                  pin8   GPIO14
GND      pin9                  pin10  GPIO15
GPIO17   pin11                 pin12  GPIO18
GPIO27   pin13                 pin14  GND
GPIO22   pin15                 pin16  GPIO23
3.3V     pin17                 pin18  GPIO24
GPIO10   pin19                 pin20  GND
GPIO9    pin21                 pin22  GPIO25
GPIO11   pin23                 pin24  GPIO8
GND      pin25                 pin26  GPIO7
ID_SD    pin27                 pin28  ID_SC
GPIO5    pin29                 pin30  GND
GPIO6    pin31                 pin32  GPIO12
GPIO13   pin33                 pin34  GND
GPIO19   pin35                 pin36  GPIO16
GPIO26   pin37                 pin38  GPIO20
GND      pin39                 pin40  GPIO21

		PORTS PORTS
_______________________________________________________________________
_______________________________________________________________________

INTELLIGENT TRAFFIC LIGHT----------------------------------------------

intelligent_system.py


import random
import time
MIN_GREEN_TIME = 10
MAX_GREEN_TIME = 60
signals = ['North', 'East', 'South', 'West']
def get_vehicle_count():
return {signal: random.randint(1, 50) for signal in signals}
def calculate_green_time(vehicle_count):
green_time = vehicle_count * 2
return max(MIN_GREEN_TIME, min(green_time, MAX_GREEN_TIME))
def traffic_light_system():
while True:
vehicle_counts = get_vehicle_count()
max_signal = max(vehicle_counts, key=vehicle_counts.get)
max_vehicle_count = vehicle_counts[max_signal]
green_time = calculate_green_time(max_vehicle_count)
print(f"Signal with priority: {max_signal}")
print(f"Number of vehicles: {max_vehicle_count}")
print(f"Green light duration: {green_time} seconds")
print('-' * 40)
time.sleep(green_time)
for signal in signals:
if signal != max_signal:
green_time_other = calculate_green_time(vehicle_counts[signal])
print(f"Signal: {signal}")
print(f"Number of vehicles: {vehicle_counts[signal]}")
print(f"Green light duration: {green_time_other} seconds")
print('-' * 40)
time.sleep(green_time_other)
if __name__ == "__main__":
traffic_light_system()

_________________________________________________________________________













































































































































































































































//RIGHT WHEEL------------------------------------------------------------------------
//     Right motor truth table
//Here are some handy tables to show the various modes of operation.
//  ENB         IN3             IN4         Description  
//  LOW   Not Applicable   Not Applicable   Motor is off
//  HIGH        LOW             LOW         Motor is stopped (brakes)
//  HIGH        LOW             HIGH        Motor is on and turning forwards
//  HIGH        HIGH            LOW         Motor is on and turning backwards
//  HIGH        HIGH            HIGH        Motor is stopped (brakes)      

// define IO pin
#define ENB 6 
#define IN3 9
#define IN4 11

//init the car
void setup() {
  pinMode(IN3, OUTPUT); //set IO pin mode OUTPUT
  pinMode(IN4, OUTPUT);
  pinMode(ENB, OUTPUT);
  digitalWrite(ENB, HIGH);  //Enable right motor       
}

//mian loop
void loop() {
  digitalWrite(IN3, LOW);      
  digitalWrite(IN4, HIGH);//Right wheel turning forwards
  delay(500);             //delay 500ms
  digitalWrite(IN3, LOW);      
  digitalWrite(IN4, LOW); //Right wheel stoped
  delay(500);
  digitalWrite(IN3, HIGH);      
  digitalWrite(IN4, LOW); //Right wheel turning backwards
  delay(500);
  digitalWrite(IN3, HIGH);      
  digitalWrite(IN4, HIGH); //Right wheel stoped
  delay(500);
}

_______________________________________________________________________________________


//LEFT WHEEL----------------------------------------------------------------------------
//     Left motor truth table
//Here are some handy tables to show the various modes of operation.
//  ENA         IN1               IN2         Description  
//  LOW   Not Applicable    Not Applicable    Motor is off
//  HIGH        LOW               LOW         Motor is stopped (brakes)
//  HIGH        HIGH              LOW         Motor is on and turning forwards
//  HIGH        LOW               HIGH        Motor is on and turning backwards
//  HIGH        HIGH              HIGH        Motor is stopped (brakes)

// define IO pin
#define ENA 5 
#define IN1 7
#define IN2 8

//init the car
void setup() {
  pinMode(IN1, OUTPUT);   //set IO pin mode OUTPUT
  pinMode(IN2, OUTPUT);
  pinMode(ENA, OUTPUT);
  digitalWrite(ENA, HIGH);//Enable left motor       
}

//mian loop
void loop() {
  digitalWrite(IN1, HIGH);      
  digitalWrite(IN2, LOW); //Right wheel turning forwards
  delay(500);             //delay 500ms
  digitalWrite(IN1, LOW);      
  digitalWrite(IN2, LOW); //Right wheel stoped
  delay(500);
  digitalWrite(IN1, LOW);      
  digitalWrite(IN2, HIGH);//Right wheel turning backwards
  delay(500);
  digitalWrite(IN1, HIGH);      
  digitalWrite(IN2, HIGH); //Right wheel stoped
  delay(500);
}

_______________________________________________________________________________________


//SPEED CONTROL------------------------------------------------------------------------
#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11

void setup() {
  pinMode(IN1,OUTPUT);
  pinMode(IN2,OUTPUT);
  pinMode(IN3,OUTPUT);
  pinMode(IN4,OUTPUT);
  pinMode(ENA,OUTPUT);
  pinMode(ENB,OUTPUT);
}

void loop() {
  //go forward
  digitalWrite(IN1,HIGH); 
  digitalWrite(IN2,LOW);  
  digitalWrite(IN3,LOW);  
  digitalWrite(IN4,HIGH);
  //reduce the speed
  for(int i = 255; i >= 0; i--){ 
    analogWrite(ENB,i);
    analogWrite(ENA,i);
    delay(20);
  }

  //stop
  analogWrite(ENB,0); //speed = 0
  analogWrite(ENA,0);  
  delay(1000);

  //runing back
  digitalWrite(IN1,LOW);
  digitalWrite(IN2,HIGH);
  digitalWrite(IN3,HIGH);
  digitalWrite(IN4,LOW);
  //accelerate
  for(int i = 0; i <= 255; i++){ 
    analogWrite(ENB,i);
    analogWrite(ENA,i);
    delay(20);
  } 
  
  //stop
  digitalWrite(ENB,LOW); //Motor is off 
  digitalWrite(ENA,LOW);  
  delay(2000);   
}



_______________________________________________________________________________________



//FOREWARD - BACKWARD -----------------------------------------------------------------

//    Left motor truth table
//  ENA         IN1               IN2         Description  
//  LOW   Not Applicable    Not Applicable    Motor is off
//  HIGH        LOW               LOW         Motor is stopped (brakes)
//  HIGH        HIGH              LOW         Motor is on and turning forwards
//  HIGH        LOW               HIGH        Motor is on and turning backwards
//  HIGH        HIGH              HIGH        Motor is stopped (brakes)

//    Right motor truth table
//  ENB         IN3             IN4         Description  
//  LOW   Not Applicable   Not Applicable   Motor is off
//  HIGH        LOW             LOW         Motor is stopped (brakes)
//  HIGH        LOW             HIGH        Motor is on and turning forwards
//  HIGH        HIGH            LOW         Motor is on and turning backwards
//  HIGH        HIGH            HIGH        Motor is stopped (brakes)  

//    The direction of the car's movement
//  Left motor    Right motor     Description  
//  stop(off)     stop(off)       Car is stopped
//  forward       forward         Car is running forwards
//  forward       backward        Car is turning right
//  backward      forward         Car is turning left
//  backward      backward        Car is running backwards

//define the L298n IO pin
#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11

void setup() {
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  digitalWrite(ENA, HIGH);  
  digitalWrite(ENB, HIGH); 
}
void loop() {
  digitalWrite(IN1, HIGH);      
  digitalWrite(IN2, LOW); 
  digitalWrite(IN3, LOW);      
  digitalWrite(IN4, HIGH);  //go forward
  delay(500);
  digitalWrite(IN1, LOW);      
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);      
  digitalWrite(IN4, LOW);   //stop
  delay(500);
  digitalWrite(IN1, LOW);      
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);      
  digitalWrite(IN4, LOW);   //go back
  delay(500);
  digitalWrite(IN1, LOW);      
  digitalWrite(IN2, LOW); 
  digitalWrite(IN3, HIGH);      
  digitalWrite(IN4, HIGH);  //stop
  delay(500);
}


_______________________________________________________________________________________


//CAR AUTO MOVE -----------------------------------------------------------------------

//    The direction of the car's movement
//  ENA   ENB   IN1   IN2   IN3   IN4   Description  
//  HIGH  HIGH  HIGH  LOW   LOW   HIGH  Car is runing forward
//  HIGH  HIGH  LOW   HIGH  HIGH  LOW   Car is runing back
//  HIGH  HIGH  LOW   HIGH  LOW   HIGH  Car is turning left
//  HIGH  HIGH  HIGH  LOW   HIGH  LOW   Car is turning right
//  HIGH  HIGH  LOW   LOW   LOW   LOW   Car is stoped
//  HIGH  HIGH  HIGH  HIGH  HIGH  HIGH  Car is stoped
//  LOW   LOW   N/A   N/A   N/A   N/A   Car is stoped


//define L298n module IO Pin
#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11

void forward(){ 
  digitalWrite(ENA,HIGH); //enable L298n A channel
  digitalWrite(ENB,HIGH); //enable L298n B channel
  digitalWrite(IN1,HIGH); //set IN1 hight level
  digitalWrite(IN2,LOW);  //set IN2 low level
  digitalWrite(IN3,LOW);  //set IN3 low level
  digitalWrite(IN4,HIGH); //set IN4 hight level
  Serial.println("Forward");//send message to serial monitor
}

void back(){
  digitalWrite(ENA,HIGH);
  digitalWrite(ENB,HIGH);
  digitalWrite(IN1,LOW);
  digitalWrite(IN2,HIGH);
  digitalWrite(IN3,HIGH);
  digitalWrite(IN4,LOW);
  Serial.println("Back");
}

void left(){
  digitalWrite(ENA,HIGH);
  digitalWrite(ENB,HIGH);
  digitalWrite(IN1,LOW);
  digitalWrite(IN2,HIGH);
  digitalWrite(IN3,LOW);
  digitalWrite(IN4,HIGH); 
  Serial.println("Left");
}

void right(){
  digitalWrite(ENA,HIGH);
  digitalWrite(ENB,HIGH);
  digitalWrite(IN1,HIGH);
  digitalWrite(IN2,LOW);
  digitalWrite(IN3,HIGH);
  digitalWrite(IN4,LOW);
  Serial.println("Right");
}

//before execute loop() function, 
//setup() function will execute first and only execute once
void setup() {
  Serial.begin(9600);//open serial and set the baudrate
  pinMode(IN1,OUTPUT);//before useing io pin, pin mode must be set first 
  pinMode(IN2,OUTPUT);
  pinMode(IN3,OUTPUT);
  pinMode(IN4,OUTPUT);
  pinMode(ENA,OUTPUT);
  pinMode(ENB,OUTPUT);
}

//Repeat execution
void loop() {
  forward();  //go forward
  delay(1000);//delay 1000 ms
  back();     //go back
  delay(1000);
  left();     //turning left
  delay(1000);
  right();    //turning right
  delay(1000);
}


_______________________________________________________________________________________

//LINE FOLLOW--------------------------------------------------------------------------

//Line Tracking IO define
#define LT_R !digitalRead(10)
#define LT_M !digitalRead(4)
#define LT_L !digitalRead(2)

#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11

#define carSpeed 150

void forward(){
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  Serial.println("go forward!");
}

void back(){
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  Serial.println("go back!");
}

void left(){
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  Serial.println("go left!");
}

void right(){
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW); 
  Serial.println("go right!");
} 

void stop(){
   digitalWrite(ENA, LOW);
   digitalWrite(ENB, LOW);
   Serial.println("Stop!");
} 

void setup(){
  Serial.begin(9600);
  pinMode(LT_R,INPUT);
  pinMode(LT_M,INPUT);
  pinMode(LT_L,INPUT);
}

void loop() {
  if(LT_M){
    forward();
  }
  else if(LT_R) { 
    right();
    while(LT_R);                             
  }   
  else if(LT_L) {
    left();
    while(LT_L);  
  }
}


_______________________________________________________________________________________

//OBSTACLE AVOIDANCE ------------------------------------------------------------------

#include <Servo.h>  //servo library
Servo myservo;      // create servo object to control servo

int Echo = A4;  
int Trig = A5; 

#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11
#define carSpeed 150
int rightDistance = 0, leftDistance = 0, middleDistance = 0;

void back(){ 
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  Serial.println("Forward");
}

void forward() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  Serial.println("Back");
}

void left() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH); 
  Serial.println("Left");
}

void right() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  Serial.println("Right");
}

void stop() {
  digitalWrite(ENA, LOW);
  digitalWrite(ENB, LOW);
  Serial.println("Stop!");
} 

//Ultrasonic distance measurement Sub function
int Distance_test() {
  digitalWrite(Trig, LOW);   
  delayMicroseconds(2);
  digitalWrite(Trig, HIGH);  
  delayMicroseconds(20);
  digitalWrite(Trig, LOW);   
  float Fdistance = pulseIn(Echo, HIGH);  
  Fdistance= Fdistance / 58;       
  return (int)Fdistance;
}  

void setup() { 
  myservo.attach(3);  // attach servo on pin 3 to servo object
  Serial.begin(9600);     
  pinMode(Echo, INPUT);    
  pinMode(Trig, OUTPUT);  
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  stop();
} 

void loop() { 
    myservo.write(90);  //setservo position according to scaled value
    delay(500); 
    middleDistance = Distance_test();

    if(middleDistance <= 20) {     
      stop();
      delay(500);                         
      myservo.write(10);          
      delay(1000);      
      rightDistance = Distance_test();
      
      delay(500);
      myservo.write(90);              
      delay(1000);                                                  
      myservo.write(180);              
      delay(1000); 
      leftDistance = Distance_test();
      
      delay(500);
      myservo.write(90);              
      delay(1000);
      if(rightDistance > leftDistance) {
        right();
        delay(360);
      }
      else if(rightDistance < leftDistance) {
        left();
        delay(360);
      }
      else if((rightDistance <= 20) || (leftDistance <= 20)) {
        forward();
        delay(180);
      }
      else {
        back();
      }
    }  
    else {
        back();
    }                     
}

_______________________________________________________________________________________

// LINE FOLLOW AND OBSTACLE AVOIDANCE--------------------------------------------------
#include <Servo.h>  // servo library

// Line Tracking IO define
#define LT_R !digitalRead(10)
#define LT_M !digitalRead(4)
#define LT_L !digitalRead(2)

// Obstacle Avoidance Pins
int Echo = A4;  
int Trig = A5; 

// Motor control pins (used by both programs)
#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11
#define carSpeed 150

// Line Tracking and Obstacle Avoidance Logic
void forward() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  Serial.println("Go forward!");
}

void back() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  Serial.println("Go back!");
}

void left() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH); 
  Serial.println("Go left!");
}

void right() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW); 
  Serial.println("Go right!");
}

void stop() {
   digitalWrite(ENA, LOW);
   digitalWrite(ENB, LOW);
   Serial.println("Stop!");
} 

// Ultrasonic distance measurement
int Distance_test() {
  digitalWrite(Trig, LOW);   
  delayMicroseconds(2);
  digitalWrite(Trig, HIGH);  
  delayMicroseconds(20);
  digitalWrite(Trig, LOW);   
  float Fdistance = pulseIn(Echo, HIGH);  
  Fdistance = Fdistance / 58;  // convert to cm
  return (int)Fdistance;
}  

void setup(){
  Serial.begin(9600);

  // Line tracking sensor pins
  pinMode(10, INPUT);  // Right
  pinMode(4, INPUT);   // Middle
  pinMode(2, INPUT);   // Left

  // Ultrasonic sensor pins
  pinMode(Echo, INPUT);    
  pinMode(Trig, OUTPUT);  

  // Motor control pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);

  stop();
}

void loop() {
  // Check the ultrasonic sensor for obstacles (10 cm threshold)
  int distance = Distance_test();

  if (distance <= 10) {
    // If obstacle is detected within 10 cm, stop the car temporarily
    stop();
    Serial.println("Obstacle detected! Waiting...");
    while (distance <= 10) {  // Wait until obstacle is removed
      distance = Distance_test();  // Keep checking the distance
    }
    Serial.println("Obstacle removed. Resuming...");
  } 

  // If no obstacle detected, perform line following behavior
  if(LT_M) {  // Middle sensor detects the line
    forward();
  } 
  else if(LT_R) {  // Right sensor detects the line
    right();
    while(LT_R);  // Keep turning right until the right sensor no longer detects the line
  }   
  else if(LT_L) {  // Left sensor detects the line
    left();
    while(LT_L);  // Keep turning left until the left sensor no longer detects the line
  }
}


_______________________________________________________________________________________

//DETECTS OBSTACLE AND PARKS-----------------------------------------------------------


#include <Servo.h>  // Servo library (if required in future enhancements)

// Line Tracking IO define
#define LT_R !digitalRead(10)
#define LT_M !digitalRead(4)
#define LT_L !digitalRead(2)

// Obstacle Avoidance Pins
int Echo = A4;  
int Trig = A5; 

// Motor control pins (used by both programs)
#define ENA 5
#define ENB 6
#define IN1 7
#define IN2 8
#define IN3 9
#define IN4 11
#define carSpeed 150

// Motor control functions
void forward() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  Serial.println("Go forward!");
}

void back() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  Serial.println("Go back!");
}

void left() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH); 
  Serial.println("Go left!");
}

void right() {
  analogWrite(ENA, carSpeed);
  analogWrite(ENB, carSpeed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW); 
  Serial.println("Go right!");
}

void stop() {
   digitalWrite(ENA, LOW);
   digitalWrite(ENB, LOW);
   Serial.println("Stop!");
} 

// Ultrasonic distance measurement
int Distance_test() {
  digitalWrite(Trig, LOW);   
  delayMicroseconds(2);
  digitalWrite(Trig, HIGH);  
  delayMicroseconds(20);
  digitalWrite(Trig, LOW);   
  float Fdistance = pulseIn(Echo, HIGH);  
  Fdistance = Fdistance / 58;  // convert to cm
  return (int)Fdistance;
}  

void setup(){
  Serial.begin(9600);

  // Line tracking sensor pins
  pinMode(10, INPUT);  // Right
  pinMode(4, INPUT);   // Middle
  pinMode(2, INPUT);   // Left

  // Ultrasonic sensor pins
  pinMode(Echo, INPUT);    
  pinMode(Trig, OUTPUT);  

  // Motor control pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);

  stop();
}

void loop() {
  // Check the ultrasonic sensor for obstacles (10 cm threshold)
  int distance = Distance_test();

  if (distance <= 10) {
    // If obstacle is detected within 10 cm, stop the car
    stop();
    Serial.println("Obstacle detected! Stopping temporarily...");
    delay(3000);  // Stop for 3 seconds
    
    // Make a sharp 90-degree turn (right turn in this case)
    Serial.println("Making a sharp 90-degree turn...");
    right();
    delay(1000);  // Adjust delay to achieve a 90-degree turn
    
    // Stop and "park" after the turn
    stop();
    Serial.println("Car parked!");
    while (true);  // End loop here to simulate parking
  } 

  // If no obstacle detected, perform line following behavior
  if(LT_M) {  // Middle sensor detects the line
    forward();
  } 
  else if(LT_R) {  // Right sensor detects the line
    right();
    while(LT_R);  // Keep turning right until the right sensor no longer detects the line
  }   
  else if(LT_L) {  // Left sensor detects the line
    left();
    while(LT_L);  // Keep turning left until the left sensor no longer detects the line
  }
}

















































































































